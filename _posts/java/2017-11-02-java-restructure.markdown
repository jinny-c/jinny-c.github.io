---
layout: category
title:  "代码重构"
description: java代码的重构。
categories: java
#categories: [java, core]
preview: /static/images/common/150/54.jpg
---

----
----


[原文地址](https://lostechies.com/seanchambers/2009/07/31/31-days-of-refactoring/)
参照：[31天重构学习笔记（java版本）](http://www.cnblogs.com/draem0507/p/4942939.html)
参照：[31天重构学习笔记重新整理下载](http://www.cnblogs.com/KnightsWarrior/p/31DaysOfRefactoring.html)



#### 封装集合
概念：本文所讲的封装集合就是把集合进行封装，只提供调用端需要的接口。

即：封装集合对象，不要暴露太多方法给外部访问内部数据

#### 移动方法
概念：本文所讲的移动方法就是方法放在合适的位置。   

#### 提升方法
概念：提升方法是指将一个很多继承类都要用到的方法提升到基类中。

简单点说，如果子类都有相同的方法，那就应该将方法提上到父类层

#### 降低方法
概念：本文中的降低方法和前篇的提升方法整好相反，也就是把个别子类使用到的方法从基类移到子类里面去。

与第三个上升方法相比，有时候，父类的方法，随着业务的变化，只适合部分子类的时候，则需要将父类的方法下移到具体需要的子类中，这样才符合接口最小原则

#### 提升字段
概念：本文中的提升字段和前面的提升方法颇为相似，就是把子类公用的字段提升到基类中，从而达到公用的目的。

#### 降低字段
概念：本文中的降低字段和前篇的提升字段正好相反，就是把基类中只有某些少数类用到的字段降低到使用它们的子类中。

#### 重命名（方法，类，参数）
概念：本文中的改名（方法，类，参数）是指在写代码的时候对类、方法、参数、委托、事件等等元素取一个有意义的名称。

总结：此重构经常被广大程序员所忽视，但是带来的隐患是不可估量的，也许老板要修改功能，那我们来看这段没有重构的代码（就算是自己写的，但由于时间和项目多等关系，我们也很难理解了），
然后就会变得焦头烂额。相反重构后的代码就会觉得一目了然、赏心悦目。

#### 使用委派代替继承
概念：本文中的“使用委派代替继承”是指在根本没有父子关系的类中使用继承是不合理的，可以用委派的方式来代替。

设计模式中，很多模式就使用了委托的方式，来解耦继承带来的强依赖，比如装饰者，适配器模式等等。

#### 提取接口
概念：本文中的“提取接口” 是指超过一个的类要使用某一个类中部分方法时，我们应该解开它们之间的依赖，让调用者使用接口，这很容易实现也可以降低代码的耦合性。

总结：这个重构策略也是一个常见的运用，很多设计模式也会在其中运用此思想（如简单工程、抽象工厂等都会通过接口来解开依赖）。


#### 提取方法
概念：本文中的把某些计算复杂的过程按照功能提取成各个小方法，这样就可以使代码的可读性、维护性得到提高。

总结：这个重构在很多公司都有一些的代码规范作为参考，比如一个类不能超过多少行代码，一个方法里面不能超过多少行代码，这在一定程度上也能使程序员把这些复杂的逻辑剥离成意义很清楚的小方法。

#### 使用策略类
概念：本文中的“使用策略类” 是指用设计模式中的策略模式来替换原来的switch case和if else语句，这样可以解开耦合，同时也使维护性和系统的可扩展性大大增强。

总结：这种重构在设计模式当中把它单独取了一个名字——策略模式，这样做的好处就是可以隔开耦合，以注入的形式实现功能，这使增加功能变得更加容易和简便，同样也增强了整个系统的稳定性和健壮性。

#### 分解依赖
概念：本文中的“分解依赖” 是指对部分不满足我们要求的类和方法进行依赖分解，通过装饰器来达到我们需要的功能。

六大设计原则中的最少知识原则(迪米特)说的就是，对依赖的了解，降低到最少。作者强调，当我们进行单元测试的时候，我们就需要一定的隔离，否则无法进行mock.这个自己也是深有体会。
良好的隔离，确实可以让单元测试的Mock变得非常的简单和容易。

总结：这个重构在很多时候和设计模式中的一些思想类似，使用中间的装饰接口来分解两个类之间的依赖，对类进行装饰，然后使它满足我们所需要的功能。

#### 提取方法对象
概念：本文中的“提取方法对象”是指当你发现一个方法中存在过多的局部变量时，你可以通过使用“提取方法对象”重构来引入一些方法，每个方法完成任务的一个步骤，这样可以使得程序变得更具有可读性。

这并不是一种很常见的重构手段，即当我们对象中定义了很多变量，及其需要利用这些变量进行一些业务操作的时候，可以考虑将方法提取到一个新的类中，这样就解耦了变量与逻辑操作的直接关联。
也比较符合单一责任原则。

#### 分离职责/单一责任
概念：本文中的“分离职责”是指当一个类有许多职责时，将部分职责分离到独立的类中，这样也符合面向对象的五大特征之一的单一职责原则，同时也可以使代码的结构更加清晰，维护性更高。

上面的问题，其实一直提到设计原则，自然也提到了单一责任原则SRP，要学重构，SRP是必然要知道，且学会的思想，并且灵活应用到重构代码中。

总结：这个重构经常会用到，它和之前的“移动方法”有几分相似之处，让方法放在合适的类中，并且简化类的职责，同时这也是面向对象五大原则之一和设计模式中的重要思想。

#### 移除重复内容
概念：本文中的“移除重复内容”是指把一些很多地方都用到的逻辑提炼出来，然后提供给调用者统一调用。

当我们有两段一样的代码的时候，很明显，我们需要对他进行简单的封装(具体如何处理，这里先不说，技巧很多种)，让重复的代码彻底消息掉。这个可能也是重构最简单，也是最好用的一种方式了

总结：这个重构很简单，绝大多数程序员都会使用这种重构方法，但有时由于习惯、时间、赶进度等原因而忽略它，所以会使得整个系统杂乱无章，到处都是Ctrl+C和Ctrl+V的痕迹。


#### 封装条件
概念：本文中的“封装条件”是指条件关系比较复杂时，代码的可读性会比较差，所以这时我们应当根据条件表达式是否需要参数将条件表达式提取成可读性更好的属性或者方法，如果条件表达式不需要参数则可以提取成属性，
如果条件表达式需要参数则可以提取成方法。

简单来说，就是对复杂的条件逻辑判断，进行单独处理，这样，当条件参数发生变化的时候，不会影响到真实的业务逻辑流程

总结：这个重构在很大程度上能改善代码的可读性，尤其是在一个逻辑很复杂的应用中，把这些条件判断封装成一个有意义的名字，这样很复杂的逻辑也会立刻变得简单起来。

#### 提取父类
概念：本文中的“提取父类”是指类中有一些字段或方法，你想把它们提取到父类中以便同一继承层次的其它类也可以访问他们，这个和之前的很多重构有异曲同工之处。

简单来说，就是当我们发现定义的方法，可以被抽象成更高层次对象的时候，就需要考虑抽象一个更上层的父类，并将接口迁移到父类中去定义

总结：这个重构是典型的继承用法，很多程序员都会选择这样做，但是要注意正确的使用，不要造成过度使用了继承，如果过度使用了，请考虑用接口、组合和聚合来实现。

#### 使用条件判断代替异常
概念：本文中的“使用条件判断代替异常”是指把没有必要使用异常做判断的条件尽量改为条件判断。

这个其实在很多语言规则中，都有提到，就是不能使用异常来代替控制逻辑，比如《effective java》一书中就有提到。

总结： 这个重构在项目代码中也经常用到，因为对于一部分程序员，是很难把握什么时候用try   catch ，什么地方该用try   catch 。记得之前大家还专门讨论过这些，比如如何用好以及在大中型项目中应该把它放在哪一个组件中等。

#### 提取工厂类
概念：本文中的“提取工厂类”是指如果要创建的对象很多，则代码会变的很复杂。一种很好的方法就是提取工厂类。

将创建对象的过程给封装起来，这就是工厂模式的设计初衷。将一些列有关系的产品簇组合成一个最终的产品，便是抽象工厂了。好像讲偏了，回归正题，使用工厂模式，从重构角度来看，就是为了实现单一职责，使得
代码更加稳定。

总结：这个重构经常会在项目中使用，如果要创建的对象是一个，你可以采用简单工厂，但是这种方式还是会存在很多依赖，维护起来也比较不方便。所以推荐使用工厂方法模式，把实例化延迟到子类。
如果你要创建一系列的对象，那么就推荐你使用抽象工厂模式，但是要注意不要过度设计，只要能满足不断变化的需求和给以后的维护和重构带来方便即可。

#### 提取子类
概念：本文中的”提取子类”是指把基类中的一些不是所有子类都需要访问的方法调整到子类中。

这个方式，之前好像已经提到的下移方法类似，也是为了遵循接口隔离原则。

总结：这个重构方法经常用来规范类的职责，和之前的一些重构方法也有些类似。

#### 合并继承
概念：本文中的”合并继承”是指如果子类的属性和方法也适合于基类，那么就可以移除子类，从而减少依赖关系。

将子类的方法迁移到父类中 不多说了

总结： 这篇和上篇其实最主要论述了子类和父类的继承关系以及如何判断什么时候需要使用继承，一般我们都能处理好这些关系，所以相对比较简单。

#### 分解方法
概念：本文中的”分解方法”是指把我们所做的这个功能不停的分解方法，直到将一个大方法分解为名字有意义且可读性更好的若干个小方法。

是不是想到了"提取方法"了，omg。

总结：其实这个重构和我们前面讲的“提取方法”和“提取方法对象”如出一辙，尤其是“提取方法”，所以大家只要知道用这种思想重构就行。

#### 引入参数对象
概念：本文中的“引入参数对象”是指当一个方法的参数过多或者过为复杂时，可以考虑把这些参数封装成一个单独的类。

此重构模式非常的好用，也非常容易上手，重点推荐

正文：如果一个方法所需要的参数大于5个，理解该方法的签名就变得比较困难，因为这样感觉参数很长、样式不好并且没有分类，所以我们有必要把参数进行封装。

总结：这种重构很重要，尤其是当一个方法的参数比较多的时候，不管是大中型项目还是小型项目，都会遇到这种场景，所以建议大家多使用这个重构。这种封装的思想在SOA 里面也经常运用到，
封装输入Message，封装输出Message，消息来和消息去以及消息间的交互就构成了整个应用体系。

#### 分解复杂判断
概念：本文中的”分解复杂判断”是指把原来复杂的条件判断等语句用尽快返回等方式简化代码。

原意是移除箭头模式，简言之，即对于复杂的逻辑判断if else{if else ..}类似这样嵌套判断，可以有一些重构的技巧
总结：这个重构很重要，它和后面讲的”尽快返回“有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。

#### 引入契约式设计
概念：本文中的”引入契约式设计”是指我们应该对应该对输入和输出进行验证，以确保系统不会出现我们所想象不到的异常和得不到我们想要的结果。

Design by contract，即要求我们对输入和输出都进行验证，已保证系统不会因为意想不到的情况出现，而导致程序出现不可以控的情况

总结：微软在处理代码乃至产品的时候，很喜欢应用此重构，你如果认真看它的代码库，认真看一下WCF的设计，就不难发现了。这个重构建议大家经常使用，这会增强整个系统的稳定性和健壮性。

#### 避免双重否定
概念：本文中的“避免双重否定”是指把代码中的双重否定语句修改成简单的肯定语句，这样即让代码可读，同时也给维护带来了方便。

总结： “双重否定”很容易让人产生错误的判断，也很难让人理解你的代码，所以这个重构在我们的代码中是很重要的，尤其是在判断条件很多且业务复杂的时候。

#### 去除上帝类
概念：本文中的“去除上帝类”是指把一个看似功能很强且很难维护的类，按照职责把自己的属性或方法分派到各自的类中或分解成功能明确的类，从而去掉上帝类。

如何理解所谓的上帝类呢，说白了，就是一些“功能强大的工具/管理类”，他可能庞大到整个业务系统只会有一个的工具类，这样就违反了单一责任原则。

总结： “去除上帝类”是我们经常容易造成的，第一是因为简便，看到有一个现成的类，大家都会喜欢把代码往里面写，最后导致越写越大，并且声明功能都有，这样即降低了可读性，也造成了维护的负担。

#### 为布尔方法命名
概念：本文中的“为布尔方法命名”是指如果一个方法带有大量的bool 参数时，可以根据bool 参数的数量，提取出若干个独立的方法来简化参数。

如果有Boolean类型参数，则为了简化外部调用带来的困难，一般会使用重命名方法来简化调用带来的困难，当然，也可以通过重载来弱化boolean变量在使用中带来的不变

总结： “为布尔方法命名”这个重构在很多时候都不常用，如果用户的参数可枚举，我们一般会枚举它的值，不过使用这种重构也有好处，就是分解开来以后，方法多了，参数少了，代码维护起来方便了一些。

#### 去除中间人对象

概念：本文中的“去除中间人对象”是指把 在中间关联而不起任何其他作用的类移除，让有关系的两个类直接进行交互。

简单理解，就是当A需要通过B去访问C的时候，并且B除了调用C的方法，不在有任何作用的时候，则B就成了所谓的中间人，就应该被delete掉

总结： “去除中间人对象”很多时候都会很有作用，尤其是在误用设计模式的代码中最容易见到，设计模式中的适配器模式和代理模式等都用中间的类是两者进行关联，这是比较合理的，因为中间类做了很多事情，
而对于没有任何作用的中间类应该移除。

#### 尽快返回
概念：  本文中的“尽快返回”是指把原来复杂的条件判断等语句用尽快返回的方式简化代码。

总结： 总结：这个重构很重要，它和前面讲的“分解复杂判断”有些类似，我们在做复杂的处理过程时，要经常考虑这个重构，用好了它，会对我们的帮助很大。

#### 使用多态代替条件判断
概念：本文中的“使用多态代替条件判断”是指如果你需要检查对象的类型或者根据类型执行一些操作时，一种很好的办法就是将算法封装到类中，并利用多态性进行抽象调用。

上面其实也提到了策略模式替换多条件，其实是类似的。如果对java的单双派机制，有更多了解的，可以移步一篇文章，[java单双派机制理解](http://www.cnblogs.com/draem0507/p/4960488.html)

总结： “使用多态代替条件判断”这个重构在很多时候会出现设计模式中（常见的工厂家族、策略模式等都可以看到它的影子），因为运用它可以省去很多的条件判断，同时也能简化代码、规范类和对象之间的职责。

